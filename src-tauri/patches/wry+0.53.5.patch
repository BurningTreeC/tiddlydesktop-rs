--- a/src/webkitgtk/drag_drop.rs
+++ b/src/webkitgtk/drag_drop.rs
@@ -104,14 +104,28 @@
   {
     let controller = controller.clone();
     webview.connect_drag_drop(move |_, ctx, x, y, time| {
+      // PATCH: Let WebKit handle ALL drops natively
+      // This preserves text insertion into inputs/textareas/contenteditables
+      // for both internal AND external drops.
+      // We still emit the Tauri event for external file drops so JS can handle them,
+      // but we return false so WebKit also processes the drop.
+
+      // For internal drops, just let WebKit handle
+      if ctx.drag_get_source_widget().is_some() {
+        return false;
+      }
+
+      // For external drops with file paths, emit the event but still return false
       if controller.state() == DragControllerState::Leaving {
         if let Some(paths) = controller.take_paths() {
-          ctx.drop_finish(true, time);
           controller.leave();
-          return controller.call(DragDropEvent::Drop {
+          // Emit the event so JS knows about the drop
+          controller.call(DragDropEvent::Drop {
             paths,
             position: (x, y),
           });
+          // But return false so WebKit also handles it natively
+          return false;
         }
       }

--- a/src/wkwebview/drag_drop.rs
+++ b/src/wkwebview/drag_drop.rs
@@ -86,13 +86,54 @@
   let frame: NSRect = this.frame();
   let position = (dl.x as i32, (frame.size.height - dl.y) as i32);

+  // PATCH: Emit the event so JS knows about the drop
   let listener = &this.ivars().drag_drop_handler;
-  if !listener(DragDropEvent::Drop { paths, position }) {
-    // Reject the Wry drop (invoke the OS default behaviour)
-    unsafe { objc2::msg_send![super(this), performDragOperation: drag_info] }
-  } else {
-    Bool::YES
+  listener(DragDropEvent::Drop { paths, position });
+
+  // PATCH: For internal drags, fix the pasteboard data before native handling.
+  // This ensures:
+  // 1. Inputs receive the correct text (tiddler title) instead of the resolved URL
+  // 2. TiddlyWiki dropzones receive the full tiddler JSON (text/vnd.tiddler)
+  unsafe {
+    // FFI functions provided by TiddlyDesktop
+    extern "C" {
+      fn tiddlydesktop_has_internal_drag() -> i32;
+      fn tiddlydesktop_get_internal_drag_text_plain() -> *const std::ffi::c_char;
+      fn tiddlydesktop_get_internal_drag_tiddler_json() -> *const std::ffi::c_char;
+    }
+
+    if tiddlydesktop_has_internal_drag() != 0 {
+      // Get the pasteboard
+      let pasteboard: *mut objc2::runtime::AnyObject = objc2::msg_send![drag_info, draggingPasteboard];
+      if !pasteboard.is_null() {
+        // Fix text/plain (for native input insertion)
+        let text_ptr = tiddlydesktop_get_internal_drag_text_plain();
+        if !text_ptr.is_null() {
+          let text_cstr = std::ffi::CStr::from_ptr(text_ptr);
+          if let Ok(text_str) = text_cstr.to_str() {
+            let ns_string = objc2_foundation::NSString::from_str(text_str);
+            let type_string = objc2_foundation::NSString::from_str("public.utf8-plain-text");
+            let _: () = objc2::msg_send![pasteboard, setString: &*ns_string, forType: &*type_string];
+          }
+        }
+
+        // Fix text/vnd.tiddler (for TiddlyWiki dropzone handlers)
+        let tiddler_ptr = tiddlydesktop_get_internal_drag_tiddler_json();
+        if !tiddler_ptr.is_null() {
+          let tiddler_cstr = std::ffi::CStr::from_ptr(tiddler_ptr);
+          if let Ok(tiddler_str) = tiddler_cstr.to_str() {
+            let ns_string = objc2_foundation::NSString::from_str(tiddler_str);
+            let type_string = objc2_foundation::NSString::from_str("text/vnd.tiddler");
+            let _: () = objc2::msg_send![pasteboard, setString: &*ns_string, forType: &*type_string];
+          }
+        }
+      }
+    }
   }
+
+  // PATCH: Always invoke native WKWebView handling
+  // This allows text/file paths to be inserted into inputs natively
+  unsafe { objc2::msg_send![super(this), performDragOperation: drag_info] }
 }

 pub(crate) fn dragging_exited(this: &WryWebView, drag_info: &ProtocolObject<dyn NSDraggingInfo>) {
--- a/src/webview2/mod.rs
+++ b/src/webview2/mod.rs
@@ -146,13 +146,13 @@
       is_child,
     )?;

+    // PATCHED: Create pass-through DragDropController
+    // This saves WebView2's original IDropTarget and forwards calls to it
+    // after extracting file paths. This enables BOTH:
+    // - Tauri drag-drop events with file paths (for external attachment support)
+    // - Native DOM drop events (for internal drags and native behavior)
+    // NOTE: We do NOT call SetAllowExternalDrop(false) - we want native drops to work!
     let drag_drop_controller = drop_handler.map(|handler| {
-      // Disable file drops, so our handler can capture it
-      unsafe {
-        let _ = controller
-          .cast::<ICoreWebView2Controller4>()
-          .and_then(|c| c.SetAllowExternalDrop(false));
-      }
       DragDropController::new(hwnd, handler)
     });

--- a/src/webview2/drag_drop.rs
+++ b/src/webview2/drag_drop.rs
@@ -2,7 +2,11 @@
 // SPDX-License-Identifier: Apache-2.0
 // SPDX-License-Identifier: MIT

-// A silly implementation of file drop handling for Windows!
+// PATCHED: Pass-through IDropTarget implementation for Windows
+// This version saves WebView2's original IDropTarget and forwards calls to it
+// after extracting file paths, enabling both:
+// - Tauri drag-drop events with file paths
+// - Native DOM drop events in WebView2

 use crate::DragDropEvent;

@@ -16,7 +20,7 @@
 };

 use windows::{
-  core::{implement, BOOL},
+  core::{implement, Interface, BOOL, PCWSTR},
   Win32::{
     Foundation::{DRAGDROP_E_INVALIDHWND, HWND, LPARAM, POINT, POINTL},
     Graphics::Gdi::ScreenToClient,
@@ -30,11 +34,14 @@
     },
     UI::{
       Shell::{DragFinish, DragQueryFileW, HDROP},
-      WindowsAndMessaging::EnumChildWindows,
+      WindowsAndMessaging::{EnumChildWindows, GetPropW},
     },
   },
 };

+/// The window property name used by OLE to store the IDropTarget
+const OLE_DROP_TARGET_PROP: PCWSTR = windows::core::w!("OleDropTargetInterface");
+
 #[derive(Default)]
 pub(crate) struct DragDropController {
   drop_targets: Vec<IDropTarget>,
@@ -65,7 +72,16 @@

   #[inline]
   fn inject_in_hwnd(&mut self, hwnd: HWND, handler: Rc<dyn Fn(DragDropEvent) -> bool>) -> bool {
-    let drag_drop_target: IDropTarget = DragDropTarget::new(hwnd, handler).into();
+    // PATCHED: Get existing IDropTarget BEFORE revoking it
+    // This allows us to forward calls to WebView2's native drop handler
+    let original_drop_target = unsafe { get_existing_drop_target(hwnd) };
+
+    #[cfg(feature = "tracing")]
+    if original_drop_target.is_some() {
+      tracing::debug!("Found existing IDropTarget on HWND {:?}, will forward drop events", hwnd);
+    }
+
+    let drag_drop_target: IDropTarget = DragDropTarget::new(hwnd, handler, original_drop_target).into();
     if unsafe { RevokeDragDrop(hwnd) } != Err(DRAGDROP_E_INVALIDHWND.into())
       && unsafe { RegisterDragDrop(hwnd, &drag_drop_target) }.is_ok()
     {
@@ -76,26 +92,62 @@
   }
 }

+/// Retrieve the existing IDropTarget from a window before we revoke it.
+/// OLE stores the IDropTarget as a window property with name "OleDropTargetInterface".
+///
+/// # Safety
+/// This function accesses raw window properties and performs COM interface casting.
+unsafe fn get_existing_drop_target(hwnd: HWND) -> Option<IDropTarget> {
+  let prop = GetPropW(hwnd, OLE_DROP_TARGET_PROP);
+  if prop.0.is_null() {
+    return None;
+  }
+
+  // The property value is a raw COM interface pointer
+  let unk_ptr = prop.0 as *mut c_void;
+  if unk_ptr.is_null() {
+    return None;
+  }
+
+  // Cast to IUnknown and QueryInterface for IDropTarget
+  // This is safe because OLE stores a valid COM pointer here
+  let unk: &windows::core::IUnknown = &*(unk_ptr as *const windows::core::IUnknown);
+
+  // QueryInterface for IDropTarget - this AddRefs the interface
+  match unk.cast::<IDropTarget>() {
+    Ok(drop_target) => Some(drop_target),
+    Err(_) => None,
+  }
+}
+
 #[implement(IDropTarget)]
 pub struct DragDropTarget {
   hwnd: HWND,
   listener: Rc<dyn Fn(DragDropEvent) -> bool>,
   cursor_effect: UnsafeCell<DROPEFFECT>,
-  enter_is_valid: UnsafeCell<bool>, /* If the currently hovered item is not valid there must not be any `HoveredFileCancelled` emitted */
+  enter_is_valid: UnsafeCell<bool>,
+  // PATCHED: Store original WebView2 IDropTarget for forwarding
+  original_drop_target: Option<IDropTarget>,
 }

 impl DragDropTarget {
-  pub fn new(hwnd: HWND, listener: Rc<dyn Fn(DragDropEvent) -> bool>) -> DragDropTarget {
+  pub fn new(
+    hwnd: HWND,
+    listener: Rc<dyn Fn(DragDropEvent) -> bool>,
+    original_drop_target: Option<IDropTarget>,
+  ) -> DragDropTarget {
     Self {
       hwnd,
       listener,
       cursor_effect: DROPEFFECT_NONE.into(),
       enter_is_valid: false.into(),
+      original_drop_target,
     }
   }

+  // PATCHED: Changed to take &IDataObject instead of Ref so we can reuse the data object
   unsafe fn iterate_filenames<F>(
-    data_obj: windows_core::Ref<'_, IDataObject>,
+    data_obj: &IDataObject,
     mut callback: F,
   ) -> Option<HDROP>
   where
@@ -109,11 +161,7 @@
       tymed: TYMED_HGLOBAL.0 as u32,
     };

-    match data_obj
-      .as_ref()
-      .expect("Received null IDataObject")
-      .GetData(&drop_format)
-    {
+    match data_obj.GetData(&drop_format) {
       Ok(medium) => {
         let hdrop = HDROP(medium.u.hGlobal.0 as _);

@@ -122,8 +170,6 @@

         for i in 0..item_count {
           // Get the length of the path string NOT including the terminating null character.
-          // Previously, this was using a fixed size array of MAX_PATH length, but the
-          // Windows API allows longer paths under certain circumstances.
           let character_count = DragQueryFileW(hdrop, i, None) as usize;

           // Fill path_buf with the null-terminated file name
@@ -141,8 +187,6 @@
           "{}",
           match _error.code() {
             windows::Win32::Foundation::DV_E_FORMATETC => {
-              // If the dropped item is not a file this error will occur.
-              // In this case it is OK to return without taking further action.
               "Error occurred while processing dropped/hovered item: item is not a file."
             }
             _ => "Unexpected error occurred while processing dropped/hovered item.",
@@ -159,31 +203,50 @@
   fn DragEnter(
     &self,
     pDataObj: windows_core::Ref<'_, IDataObject>,
-    _grfKeyState: MODIFIERKEYS_FLAGS,
+    grfKeyState: MODIFIERKEYS_FLAGS,
     pt: &POINTL,
     pdwEffect: *mut DROPEFFECT,
   ) -> windows::core::Result<()> {
-    let mut pt = POINT { x: pt.x, y: pt.y };
-    let _ = unsafe { ScreenToClient(self.hwnd, &mut pt) };
+    // Get reference to the data object for reuse
+    let data_obj = pDataObj.as_ref().expect("Received null IDataObject");
+
+    let mut client_pt = POINT { x: pt.x, y: pt.y };
+    let _ = unsafe { ScreenToClient(self.hwnd, &mut client_pt) };

+    // Extract file paths for our event
     let mut paths = Vec::new();
-    let hdrop = unsafe { DragDropTarget::iterate_filenames(pDataObj, |path| paths.push(path)) };
+    let hdrop = unsafe { DragDropTarget::iterate_filenames(data_obj, |path| paths.push(path)) };

     let enter_is_valid = hdrop.is_some();

-    if !enter_is_valid {
-      return Ok(());
-    };
-
     unsafe {
       *self.enter_is_valid.get() = enter_is_valid;
     }

-    (self.listener)(DragDropEvent::Enter {
-      paths,
-      position: (pt.x as _, pt.y as _),
-    });
+    // Emit our event with file paths (if files present)
+    if enter_is_valid {
+      (self.listener)(DragDropEvent::Enter {
+        paths,
+        position: (client_pt.x as _, client_pt.y as _),
+      });
+    }

+    // PATCHED: Forward to original WebView2 IDropTarget
+    // This allows native DOM dragenter events to fire
+    if let Some(ref original) = self.original_drop_target {
+      let result = unsafe {
+        original.DragEnter(data_obj, grfKeyState, *pt, pdwEffect)
+      };
+
+      // Store the effect the original wants
+      if !pdwEffect.is_null() {
+        unsafe { *self.cursor_effect.get() = *pdwEffect };
+      }
+
+      return result;
+    }
+
+    // Fallback: No original drop target, handle ourselves
     let cursor_effect = if enter_is_valid {
       DROPEFFECT_COPY
     } else {
@@ -191,7 +254,9 @@
     };

     unsafe {
-      *pdwEffect = cursor_effect;
+      if !pdwEffect.is_null() {
+        *pdwEffect = cursor_effect;
+      }
       *self.cursor_effect.get() = cursor_effect;
     }

@@ -200,47 +265,87 @@

   fn DragOver(
     &self,
-    _grfKeyState: MODIFIERKEYS_FLAGS,
+    grfKeyState: MODIFIERKEYS_FLAGS,
     pt: &POINTL,
     pdwEffect: *mut DROPEFFECT,
   ) -> windows::core::Result<()> {
+    // Emit position event if valid
     if unsafe { *self.enter_is_valid.get() } {
-      let mut pt = POINT { x: pt.x, y: pt.y };
-      let _ = unsafe { ScreenToClient(self.hwnd, &mut pt) };
+      let mut client_pt = POINT { x: pt.x, y: pt.y };
+      let _ = unsafe { ScreenToClient(self.hwnd, &mut client_pt) };
       (self.listener)(DragDropEvent::Over {
-        position: (pt.x as _, pt.y as _),
+        position: (client_pt.x as _, client_pt.y as _),
       });
     }

-    unsafe { *pdwEffect = *self.cursor_effect.get() };
+    // PATCHED: Forward to original WebView2 IDropTarget
+    if let Some(ref original) = self.original_drop_target {
+      let result = unsafe { original.DragOver(grfKeyState, *pt, pdwEffect) };
+
+      // Store the effect
+      if !pdwEffect.is_null() {
+        unsafe { *self.cursor_effect.get() = *pdwEffect };
+      }
+
+      return result;
+    }
+
+    // Fallback
+    unsafe {
+      if !pdwEffect.is_null() {
+        *pdwEffect = *self.cursor_effect.get();
+      }
+    }
     Ok(())
   }

   fn DragLeave(&self) -> windows::core::Result<()> {
+    // Emit leave event if valid
     if unsafe { *self.enter_is_valid.get() } {
       (self.listener)(DragDropEvent::Leave);
     }
+
+    // PATCHED: Forward to original WebView2 IDropTarget
+    if let Some(ref original) = self.original_drop_target {
+      return unsafe { original.DragLeave() };
+    }
+
     Ok(())
   }

   fn Drop(
     &self,
     pDataObj: windows_core::Ref<'_, IDataObject>,
-    _grfKeyState: MODIFIERKEYS_FLAGS,
+    grfKeyState: MODIFIERKEYS_FLAGS,
     pt: &POINTL,
-    _pdwEffect: *mut DROPEFFECT,
+    pdwEffect: *mut DROPEFFECT,
   ) -> windows::core::Result<()> {
+    // Get reference to the data object for reuse
+    let data_obj = pDataObj.as_ref().expect("Received null IDataObject");
+
     if unsafe { *self.enter_is_valid.get() } {
-      let mut pt = POINT { x: pt.x, y: pt.y };
-      let _ = unsafe { ScreenToClient(self.hwnd, &mut pt) };
+      let mut client_pt = POINT { x: pt.x, y: pt.y };
+      let _ = unsafe { ScreenToClient(self.hwnd, &mut client_pt) };

+      // Extract file paths for our event
       let mut paths = Vec::new();
-      let hdrop = unsafe { DragDropTarget::iterate_filenames(pDataObj, |path| paths.push(path)) };
+      let hdrop = unsafe { DragDropTarget::iterate_filenames(data_obj, |path| paths.push(path)) };
+
+      // Emit our event with file paths BEFORE forwarding
+      // This ensures Tauri gets the paths regardless of what the original does
       (self.listener)(DragDropEvent::Drop {
         paths,
-        position: (pt.x as _, pt.y as _),
+        position: (client_pt.x as _, client_pt.y as _),
       });

+      // PATCHED: Forward to original WebView2 IDropTarget
+      // The original will handle the drop and generate native DOM drop events
+      // We do NOT call DragFinish - the original will handle that
+      if let Some(ref original) = self.original_drop_target {
+        return unsafe { original.Drop(data_obj, grfKeyState, *pt, pdwEffect) };
+      }
+
+      // Fallback: No original, call DragFinish ourselves
       if let Some(hdrop) = hdrop {
         unsafe { DragFinish(hdrop) };
       }
