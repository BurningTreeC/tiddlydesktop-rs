diff --git a/src/webkitgtk/drag_drop.rs b/src/webkitgtk/drag_drop.rs
index 5133713..931ae82 100644
--- a/src/webkitgtk/drag_drop.rs
+++ b/src/webkitgtk/drag_drop.rs
@@ -104,14 +104,28 @@ pub(crate) fn connect_drag_event(webview: &WebView, handler: Box<dyn Fn(DragDrop
   {
     let controller = controller.clone();
     webview.connect_drag_drop(move |_, ctx, x, y, time| {
+      // PATCH: Let WebKit handle ALL drops natively
+      // This preserves text insertion into inputs/textareas/contenteditables
+      // for both internal AND external drops.
+      // We still emit the Tauri event for external file drops so JS can handle them,
+      // but we return false so WebKit also processes the drop.
+
+      // For internal drops, just let WebKit handle
+      if ctx.drag_get_source_widget().is_some() {
+        return false;
+      }
+
+      // For external drops with file paths, emit the event but still return false
       if controller.state() == DragControllerState::Leaving {
         if let Some(paths) = controller.take_paths() {
-          ctx.drop_finish(true, time);
           controller.leave();
-          return controller.call(DragDropEvent::Drop {
+          // Emit the event so JS knows about the drop
+          controller.call(DragDropEvent::Drop {
             paths,
             position: (x, y),
           });
+          // But return false so WebKit also handles it natively
+          return false;
         }
       }
 
diff --git a/src/webview2/drag_drop.rs b/src/webview2/drag_drop.rs
index 960a07f..82e8c36 100644
--- a/src/webview2/drag_drop.rs
+++ b/src/webview2/drag_drop.rs
@@ -184,6 +184,26 @@ impl IDropTarget_Impl for DragDropTarget_Impl {
       position: (pt.x as _, pt.y as _),
     });
 
+
+    // PATCH: Call FFI to store file paths for TiddlyDesktop
+    // This allows JavaScript to access paths when native DOM drop fires
+    unsafe {
+      extern "C" {
+        fn tiddlydesktop_store_drop_paths(paths_json: *const std::ffi::c_char);
+      }
+      // Manually construct JSON array (avoids serde_json dependency)
+      let json_parts: Vec<String> = paths.iter().map(|p| {
+        let s = p.to_string_lossy();
+        // Escape backslashes and quotes for JSON
+        let escaped = s.replace('\\', "\\\\").replace('"', "\\\"");
+        format!("\"{}\"", escaped)
+      }).collect();
+      let json = format!("[{}]", json_parts.join(","));
+      if let Ok(cstr) = std::ffi::CString::new(json) {
+        tiddlydesktop_store_drop_paths(cstr.as_ptr());
+      }
+    }
+
     let cursor_effect = if enter_is_valid {
       DROPEFFECT_COPY
     } else {
@@ -219,6 +239,14 @@ impl IDropTarget_Impl for DragDropTarget_Impl {
   fn DragLeave(&self) -> windows::core::Result<()> {
     if unsafe { *self.enter_is_valid.get() } {
       (self.listener)(DragDropEvent::Leave);
+
+      // PATCH: Clear stored paths on drag leave
+      unsafe {
+        extern "C" {
+          fn tiddlydesktop_clear_drop_paths();
+        }
+        tiddlydesktop_clear_drop_paths();
+      }
     }
     Ok(())
   }
@@ -241,6 +269,26 @@ impl IDropTarget_Impl for DragDropTarget_Impl {
         position: (pt.x as _, pt.y as _),
       });
 
+      // PATCH: Call FFI to store file paths for TiddlyDesktop
+      // This ensures paths are available when native DOM drop event fires
+      unsafe {
+        extern "C" {
+          fn tiddlydesktop_store_drop_paths(paths_json: *const std::ffi::c_char);
+        }
+        // Manually construct JSON array (avoids serde_json dependency)
+        let json_parts: Vec<String> = paths.iter().map(|p| {
+          let s = p.to_string_lossy();
+          // Escape backslashes and quotes for JSON
+          let escaped = s.replace('\\', "\\\\").replace('"', "\\\"");
+          format!("\"{}\"", escaped)
+        }).collect();
+        let json = format!("[{}]", json_parts.join(","));
+        if let Ok(cstr) = std::ffi::CString::new(json) {
+          tiddlydesktop_store_drop_paths(cstr.as_ptr());
+        }
+      }
+
+
       if let Some(hdrop) = hdrop {
         unsafe { DragFinish(hdrop) };
       }
diff --git a/src/webview2/mod.rs b/src/webview2/mod.rs
index a2f5d5b..2cf1007 100644
--- a/src/webview2/mod.rs
+++ b/src/webview2/mod.rs
@@ -146,13 +146,10 @@ impl InnerWebView {
       is_child,
     )?;
 
+    // PATCH: Don't disable external drops - let WebView2 also handle them natively
+    // WRY's IDropTarget extracts paths via FFI, WebView2 generates DOM events
     let drag_drop_controller = drop_handler.map(|handler| {
-      // Disable file drops, so our handler can capture it
-      unsafe {
-        let _ = controller
-          .cast::<ICoreWebView2Controller4>()
-          .and_then(|c| c.SetAllowExternalDrop(false));
-      }
+      // Don't call SetAllowExternalDrop(false) - let WebView2 also handle drops natively
       DragDropController::new(hwnd, handler)
     });
 
diff --git a/src/wkwebview/drag_drop.rs b/src/wkwebview/drag_drop.rs
index e28364e..b9043a9 100644
--- a/src/wkwebview/drag_drop.rs
+++ b/src/wkwebview/drag_drop.rs
@@ -86,13 +86,54 @@ pub(crate) fn perform_drag_operation(
   let frame: NSRect = this.frame();
   let position = (dl.x as i32, (frame.size.height - dl.y) as i32);
 
+  // PATCH: Emit the event so JS knows about the drop
   let listener = &this.ivars().drag_drop_handler;
-  if !listener(DragDropEvent::Drop { paths, position }) {
-    // Reject the Wry drop (invoke the OS default behaviour)
-    unsafe { objc2::msg_send![super(this), performDragOperation: drag_info] }
-  } else {
-    Bool::YES
+  listener(DragDropEvent::Drop { paths, position });
+
+  // PATCH: For internal drags, fix the pasteboard data before native handling.
+  // This ensures:
+  // 1. Inputs receive the correct text (tiddler title) instead of the resolved URL
+  // 2. TiddlyWiki dropzones receive the full tiddler JSON (text/vnd.tiddler)
+  unsafe {
+    // FFI functions provided by TiddlyDesktop
+    extern "C" {
+      fn tiddlydesktop_has_internal_drag() -> i32;
+      fn tiddlydesktop_get_internal_drag_text_plain() -> *const std::ffi::c_char;
+      fn tiddlydesktop_get_internal_drag_tiddler_json() -> *const std::ffi::c_char;
+    }
+
+    if tiddlydesktop_has_internal_drag() != 0 {
+      // Get the pasteboard
+      let pasteboard: *mut objc2::runtime::AnyObject = objc2::msg_send![drag_info, draggingPasteboard];
+      if !pasteboard.is_null() {
+        // Fix text/plain (for native input insertion)
+        let text_ptr = tiddlydesktop_get_internal_drag_text_plain();
+        if !text_ptr.is_null() {
+          let text_cstr = std::ffi::CStr::from_ptr(text_ptr);
+          if let Ok(text_str) = text_cstr.to_str() {
+            let ns_string = objc2_foundation::NSString::from_str(text_str);
+            let type_string = objc2_foundation::NSString::from_str("public.utf8-plain-text");
+            let _: () = objc2::msg_send![pasteboard, setString: &*ns_string, forType: &*type_string];
+          }
+        }
+
+        // Fix text/vnd.tiddler (for TiddlyWiki dropzone handlers)
+        let tiddler_ptr = tiddlydesktop_get_internal_drag_tiddler_json();
+        if !tiddler_ptr.is_null() {
+          let tiddler_cstr = std::ffi::CStr::from_ptr(tiddler_ptr);
+          if let Ok(tiddler_str) = tiddler_cstr.to_str() {
+            let ns_string = objc2_foundation::NSString::from_str(tiddler_str);
+            let type_string = objc2_foundation::NSString::from_str("text/vnd.tiddler");
+            let _: () = objc2::msg_send![pasteboard, setString: &*ns_string, forType: &*type_string];
+          }
+        }
+      }
+    }
   }
+
+  // PATCH: Always invoke native WKWebView handling
+  // This allows text/file paths to be inserted into inputs natively
+  unsafe { objc2::msg_send![super(this), performDragOperation: drag_info] }
 }
 
 pub(crate) fn dragging_exited(this: &WryWebView, drag_info: &ProtocolObject<dyn NSDraggingInfo>) {
